# Decorator Pattern

React Native에서 권한 검사 기능을 함수에 동적으로 추가하는 데코레이터 패턴 예제

---

## Decorator 패턴 개념

- 기존 객체나 함수에 새로운 기능을 동적으로 추가하는 구조적 디자인 패턴
- 상속 대신 조합을 통해 기능 확장이 가능하며, 코드 중복 없이 관심사를 분리할 수 있음
- 원본 객체(함수)를 수정하지 않고도 부가 기능(권한 체크, 로깅 등)을 덧붙일 수 있음

---

## Decorator 패턴 핵심 원칙

1. **원본 기능(컴포넌트 또는 함수) 보존**

   - 기존 기능을 그대로 유지하며 확장 가능

2. **추가 기능을 분리된 데코레이터에 구현**

   - 부가 기능을 독립적으로 관리하여 재사용성 증가

3. **원본과 동일한 인터페이스를 유지**
   - 클라이언트는 데코레이터를 의식하지 않고 동일하게 호출 가능

---

## React Native 예제 구성

- `deleteUserData` 함수: 사용자 데이터를 삭제하는 원본 함수
- `withAuthorization` 데코레이터: 함수 실행 전 사용자 권한(`admin` 또는 `guest`)을 체크하여 권한이 없으면 동작을 막음
- `DeleteButton` 컴포넌트: 삭제 버튼 UI, 클릭 시 권한 검사된 삭제 함수 호출
- `App.tsx`: 스위치로 권한 상태를 토글하며, 데코레이터가 적용된 삭제 함수를 `DeleteButton`에 전달

---

## 사용 예시

- 앱에서 사용자 권한을 `admin`과 `guest`로 구분하고, 민감한 기능(데이터 삭제)을 권한에 따라 제한하고자 할 때
- 원본 `deleteUserData` 함수는 단순히 삭제 기능만 수행
- `withAuthorization` 데코레이터를 적용해 권한 검증 로직을 분리하여 재사용 가능하게 만듦
- 권한이 없는 상태에서 삭제 버튼을 눌러도 삭제 동작이 차단되고, 권한이 있을 때만 정상 작동
- 권한 상태는 스위치 UI를 통해 쉽게 변경 가능하며, UI 컴포넌트는 데코레이터 적용 여부를 신경 쓸 필요 없음
- 덕분에 권한 검증 로직과 UI 로직이 명확히 분리되고 유지보수가 쉬워짐

---

## React Native에서 활용

- 권한 검증, 로깅, 캐싱 등 부가 기능을 함수 또는 컴포넌트에 동적으로 추가할 때 유용
- 기존 코드를 최소한으로 변경하면서 기능을 확장 가능
- 함수형 컴포넌트 및 훅 환경과도 잘 어울려 모던 React Native 개발에 적합
- 관심사 분리와 코드 재사용성을 극대화하는 데코레이터 패턴 활용 가능

---
