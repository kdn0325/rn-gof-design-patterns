# Flyweight

메모리와 성능 최적화를 위해 동일한 데이터나 객체를 공유하여 사용하는 Flyweight 패턴 예제  
React Native에서 알림 리스트의 아이콘, 스타일, 메시지 템플릿을 타입별로 캐싱해 효율적으로 관리하는 사례

---

## Flyweight 패턴 개념

- 객체를 공유하여 메모리 사용량을 최소화하는 구조적 디자인 패턴
- 같은 종류의 객체가 여러 개 필요할 때, 공통 상태를 공유(flyweight)하고 변하는 부분만 외부에서 관리(extrinsic state)
- 불필요한 중복 객체 생성을 방지해 성능과 메모리 효율을 높임

---

## Flyweight 패턴 핵심 원칙

1. **공유 가능한 상태 분리**

   - 객체의 공유 가능한 내부 상태(intrinsic state)를 별도로 분리하여 재사용

2. **외부 상태 분리**

   - 변하는 외부 상태(extrinsic state)는 공유 객체에 저장하지 않고 호출 시 전달

3. **중복 객체 생성 방지**

   - 공유 저장소(cache, pool)를 통해 동일한 객체를 재사용하여 메모리 낭비 최소화

---

## React Native 예제 구성

- `IconFactory`, `StyleFactory`, `MessageFactory`: 타입별 아이콘, 스타일, 메시지 템플릿을 생성 및 캐싱하는 Flyweight 저장소
- `NotificationItem` 컴포넌트: 각 알림 아이템에서 타입에 맞는 공유 아이콘, 스타일, 메시지 템플릿을 재사용하여 렌더링
- `username` 같은 변하는 정보는 외부에서 전달(외부 상태)
- 캐시된 객체는 메모리에 단 한번만 생성되어 여러 알림 아이템에서 공유됨

---

## 사용 예시

- 알림 리스트 같은 반복 렌더링에서 아이콘, 스타일, 메시지 템플릿을 타입별로 캐싱해 중복 생성 방지
- 알림 타입별로 공통된 UI 요소를 메모리에 하나만 생성해 성능과 메모리 최적화
- 변하는 부분(예: username)은 외부에서 전달하여 유연하게 재사용 가능
- 대규모 알림이나 데이터 리스트가 많은 앱에서 효과적

---

## React Native에서 활용

- UI 컴포넌트의 아이콘, 스타일, 텍스트 템플릿 같은 공통 자원을 공유할 때 유용
- 메모리 제한이 있는 모바일 환경에서 성능 최적화에 특히 적합
- 반복 렌더링과 많은 인스턴스 생성이 예상되는 곳에 적용하면 효율적
- Flyweight 저장소를 잘 설계하면 유지보수와 확장성도 개선됨
